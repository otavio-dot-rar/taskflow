---
description: Structure and parsing of .mdc files, JSON types and serialization - activate when working with .mdc files
globs: 
alwaysApply: false
---
# Formato de Dados .mdc

## Anatomia de um Arquivo .mdc

### Estrutura B√°sica
```markdown
---
# === CURSOR FIELDS (obrigat√≥rios) ===
description: "Descri√ß√£o da regra (vazio para Always Applied)"
globs: []
alwaysApply: false

# === TASKFLOW CORE FIELDS ===
type: "task"           # task | documentation | reference
status: "todo"         # todo | in-progress | done
priority: "high"       # high | medium | low
phase: "phase-4"       # identificador da fase
---

# T√≠tulo Principal

## üîß Task 4.1: Nome da Task

### **Status: üìã EM PROGRESSO**
**Prioridade:** Alta | **ETA:** 1-2 dias

### **Crit√©rios de Aceite**
- [ ] Tarefa n√£o completa
- [x] Tarefa completa
  - [ ] Subtarefa 1
  - [x] Subtarefa 2
```

## Mapeamento para Estrutura JSON

### Frontmatter (YAML Header)
```yaml
---
# === CURSOR FIELDS (obrigat√≥rios para compatibilidade) ===
description: "Descri√ß√£o da regra" # Presente APENAS em Agent Requested
globs: ["*.ts", "*.tsx"] # Padr√µes glob (opcional)
alwaysApply: false # true = Always, false = Agent Requested/Manual

# === TASKFLOW CORE FIELDS (nossos) ===
type: "task"           # task | documentation | reference
status: "todo"         # todo | in-progress | done
priority: "high"       # high | medium | low
phase: "phase-4"       # identificador da fase
---
```

**Mapping e L√≥gica de Classifica√ß√£o:**
```typescript
interface Metadata {
  // === CURSOR FIELDS ===
  description?: string; // Presente APENAS em Agent Requested
  globs?: string | string[];
  alwaysApply: boolean;
  
  // === TASKFLOW CORE FIELDS ===
  type?: "task" | "documentation" | "reference";
  status?: "todo" | "in-progress" | "done";
  priority?: "high" | "medium" | "low";
  phase?: string;
  
  // Legacy/computed fields
  tags?: string[];
}

type RuleType = "Always" | "Agent Requested" | "Manual";

function getRuleType(metadata: Metadata): RuleType {
  if (metadata.alwaysApply) return "Always";
  if (metadata.description && metadata.description.trim() !== "") return "Agent Requested";
  return "Manual"; // alwaysApply: false mas sem description
}
```

**Padr√µes de Uso:**
- **Documentation (Always):** `alwaysApply: true` + `description: ""` + `type: "documentation"`
- **Tasks (Agent Requested):** `alwaysApply: false` + `description: "..."` + `type: "task"`
- **Reference (Manual):** `alwaysApply: false` + `description: ""` + `type: "reference"`

**Extens√£o para IA (Fase 4):**
- **AI Generated:** `alwaysApply: false` + `description: "Generated by AI"` + `aiGenerated: true` (novo campo opcional)

### Hierarquia de Conte√∫do

| Markdown | Elemento Visual | Tipo JSON |
|----------|-----------------|-----------|
| `# T√≠tulo` | Header da p√°gina | `{ type: 'title', text: string }` |
| `## Fase` | Coluna Kanban | `{ type: 'phase', name: string, items: [] }` |
| `### Etapa` | Separador/Header | `{ type: 'step', name: string }` |
| `- [ ] Tarefa` | Card Kanban | `{ type: 'task', text: string, completed: false, subtasks: [] }` |
| `- [x] Tarefa` | Card Completo | `{ type: 'task', text: string, completed: true }` |
| `  - [ ] Sub` | Checkbox interno | `{ text: string, completed: false }` |

## Estrutura JSON Completa

```typescript
interface WorkspaceFile {
  filePath: string;
  fileName: string;
  metadata: Metadata;
  content: {
    title?: string;
    phases: Phase[];
  };
  lastModified: Date;
}

interface Phase {
  id: string;
  name: string;
  items: (Step | Task)[];
}

interface Step {
  type: 'step';
  id: string;
  name: string;
}

interface Task {
  type: 'task';
  id: string;
  text: string;
  completed: boolean;
  subtasks: SubTask[];
  originalPhaseId: string; // Para drag & drop
}

interface SubTask {
  id: string;
  text: string;
  completed: boolean;
}
```

## Regras de Parsing

### 1. Frontmatter Obrigat√≥rio
- **Todo arquivo .mdc DEVE ter frontmatter YAML**
- **Campos obrigat√≥rios:** `ruleType`, `description`
- **Parsing:** Usar `gray-matter` library

```typescript
import matter from 'gray-matter';

const { data: metadata, content } = matter(fileContent);
```

### 2. Hierarquia Markdown
- **`##` cria nova Fase (coluna kanban)**
- **`###` cria Etapa (separador visual)**
- **`- [ ]` ou `- [x]` cria Tarefa**
- **Indenta√ß√£o com 2 espa√ßos cria Subtarefa**

### 3. Links Entre Arquivos
- **Formato:** `[texto](mdc:caminho/arquivo.mdc)`
- **Resolu√ß√£o:** Relativo ao workspace root
- **Exemplo:** `[Ver detalhes](mdc:details/task-detail.mdc)`

### 4. IDs √önicos
- **Gera√ß√£o:** UUID v4 ou incremento baseado em conte√∫do
- **Persist√™ncia:** IDs s√£o gerados no parsing, n√£o salvos no .mdc
- **Estabilidade:** Mesmo ID para mesmo conte√∫do entre sess√µes

## Implementa√ß√£o do Parser

### Main Process (Node.js)
```typescript
// src-main/services/mdc-parser.ts
import matter from 'gray-matter';
import { marked } from 'marked';

export class MdcParser {
  static parseFile(filePath: string): WorkspaceFile {
    const content = fs.readFileSync(filePath, 'utf-8');
    const { data: metadata, content: markdownContent } = matter(content);
    
    const phases = this.parsePhases(markdownContent);
    
    return {
      filePath,
      fileName: path.basename(filePath),
      metadata: metadata as Metadata,
      content: { phases },
      lastModified: fs.statSync(filePath).mtime
    };
  }

  private static parsePhases(markdown: string): Phase[] {
    // Implementar regex/marked para hierarquia
    // ## ‚Üí nova fase
    // ### ‚Üí nova etapa
    // - [ ] ‚Üí nova tarefa
  }
}
```

### Serializa√ß√£o de Volta para .mdc
```typescript
// src-main/services/mdc-serializer.ts
export class MdcSerializer {
  static serialize(workspaceFile: WorkspaceFile): string {
    const frontmatter = matter.stringify('', workspaceFile.metadata);
    const content = this.buildMarkdownContent(workspaceFile.content);
    
    return frontmatter + content;
  }

  private static buildMarkdownContent(content: any): string {
    let markdown = '';
    
    for (const phase of content.phases) {
      markdown += `\n## ${phase.name}\n\n`;
      
      for (const item of phase.items) {
        if (item.type === 'step') {
          markdown += `### ${item.name}\n`;
        } else if (item.type === 'task') {
          const checkbox = item.completed ? '[x]' : '[ ]';
          markdown += `- ${checkbox} ${item.text}\n`;
          
          for (const subtask of item.subtasks) {
            const subCheckbox = subtask.completed ? '[x]' : '[ ]';
            markdown += `  - ${subCheckbox} ${subtask.text}\n`;
          }
        }
      }
    }
    
    return markdown;
  }
}
```

## Valida√ß√£o e Integridade

### Regras de Valida√ß√£o
1. **Frontmatter v√°lido:** YAML bem formado
2. **Campos obrigat√≥rios:** `description` e `alwaysApply` presentes
3. **Hierarquia v√°lida:** N√£o pode ter tarefa sem fase
4. **Links v√°lidos:** Arquivos referenciados existem
5. **Encoding:** UTF-8 obrigat√≥rio
6. **Globs v√°lidos:** Padr√µes glob bem formados (se presentes)

### Backup e Recupera√ß√£o
- **Backup autom√°tico:** `.mdc.bak` antes de cada save
- **Valida√ß√£o pr√©-save:** Verificar integridade antes sobrescrever
- **Rollback:** Capacidade de restaurar backup em caso de erro

## Exemplos Pr√°ticos

### Arquivo de Exemplo: `project-plan.mdc`
```markdown
---
description: Plano de desenvolvimento do projeto TaskFlow
globs: ["*.ts", "*.tsx"]
alwaysApply: true
priority: high
tags: ["mvp", "planning"]
---

# Plano de Desenvolvimento TaskFlow

## Fase 1: Foundation
### Etapa 1.1: Setup
- [x] Configurar Electron
- [x] Configurar Next.js
- [ ] Integrar shadcn/ui

### Etapa 1.2: Basic UI
- [ ] Criar layout principal
- [ ] Implementar sidebar

## Fase 2: Core Features  
### Etapa 2.1: File Reading
- [ ] Parser .mdc
  - [ ] Frontmatter parsing
  - [ ] Content parsing
- [ ] File system integration
```

### JSON Resultante:
```json
{
  "filePath": "/project/.cursor/rules/project-plan.mdc",
  "fileName": "project-plan.mdc",
  "metadata": {
    "description": "Plano de desenvolvimento do projeto TaskFlow",
    "globs": ["*.ts", "*.tsx"],
    "alwaysApply": true,
    "priority": "high",
    "tags": ["mvp", "planning"]
  },
  "content": {
    "title": "Plano de Desenvolvimento TaskFlow",
    "phases": [
      {
        "id": "phase-1",
        "name": "Foundation",
        "items": [
          {
            "type": "step",
            "id": "step-1-1",
            "name": "Setup"
          },
          {
            "type": "task",
            "id": "task-1",
            "text": "Configurar Electron", 
            "completed": true,
            "subtasks": []
          }
          // ... mais itens
        ]
      }
    ]
  }
}
```

## Extens√£o para IA (Fase 4)

### Gera√ß√£o Autom√°tica de Arquivos .mdc

#### Template para IA-Generated
```markdown
---
description: "Generated by AI from user prompt"
globs: ["*.ts", "*.tsx"] 
alwaysApply: false
aiGenerated: true
aiPrompt: "Create a project plan for a React dashboard application"
priority: medium
tags: ["ai-generated", "project-plan"]
---

# [T√≠tulo Gerado pela IA]

## Fase 1: [Nome da Fase]
### [Nome da Etapa]
- [ ] [Tarefa gerada pela IA]
- [ ] [Outra tarefa]
  - [ ] [Subtarefa detalhada]

## Fase 2: [Pr√≥xima Fase]
...
```

#### Fluxo de Integra√ß√£o IA
```typescript
// 1. Usu√°rio fornece prompt
const userPrompt = "Create a project plan for building a task management app";

// 2. IA gera estrutura .mdc
const aiResponse = await generateProjectPlan(userPrompt);

// 3. Converte resposta IA para formato .mdc v√°lido
const mdcContent = convertAIResponseToMdc(aiResponse, userPrompt);

// 4. Salva arquivo tempor√°rio
const tempPath = await saveTempMdcFile(mdcContent);

// 5. Parser existente processa o arquivo
const workspace = await MdcParser.parseFile(tempPath);

// 6. Carrega na interface (Dashboard/Kanban)
loadWorkspaceIntoUI(workspace);
```

#### Identifica√ß√£o de Arquivos IA
```typescript
function isAIGenerated(metadata: Metadata): boolean {
  return metadata.aiGenerated === true;
}

// Badge visual na UI para arquivos gerados por IA
<Badge variant="secondary">
  ü§ñ AI Generated
</Badge>
```

### Compatibilidade Total
- **Parser existente:** Funciona sem modifica√ß√£o
- **Serializer existente:** Funciona sem modifica√ß√£o  
- **UI existente:** Funciona sem modifica√ß√£o
- **Novos campos:** Totalmente opcionais
- **Formato Cursor:** Mantido 100% compat√≠vel











